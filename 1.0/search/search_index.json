{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Power-events!","text":"<p>Take control of your event routing, effortlessly and tailored to your needs.</p>"},{"location":"#description","title":"Description","text":"<p>Power-events is a lightweight yet powerful library that manages event routing by defining routes with precise conditions, inspired by FastAPI\u2019s endpoint routing system. It simplifies the organization of complex events by applying specific routing rules defined  by the user and enables actions to be triggered in response to events in a structured manner.</p>"},{"location":"#key-features","title":"Key features:","text":"<ul> <li>Syntax: Lean to standards like Powertools or FastAPI.</li> <li>Easy: Design to be easy to read and use.</li> <li>Flexible: You can do whatever condition at any depth level in your event.</li> <li>Fully tested: 100% coverage.</li> <li>Fully typed: compatible out of the box with <code>mypy</code> !</li> <li>Lightweight</li> </ul>"},{"location":"#examples","title":"Examples","text":""},{"location":"#simple-conditions","title":"Simple conditions","text":"<ul> <li>create a <code>main.py</code> with:</li> </ul> <pre><code>from typing import Any\nfrom power_events import EventResolver\n\napp = EventResolver()\n\n@app.equal(\"type\", \"order_created\")\ndef handler_order_created(event: dict[str, Any]) -&gt; str:\n  return f\"Order created: {event['order_id']}\"\n\n@app.one_of(\"type\", [\"order_update\", \"order_delete\"])\ndef handle_order_modification(event: dict[str, Any]) -&gt; str:\n  return f\"Order modification &lt;{event['type']}&gt;: {event['order_id']}\"\n</code></pre> <ul> <li>use routing:</li> </ul> <p>N.B: assert is here to show which route has been called. In real condition, don't need to use it.</p> <pre><code>assert app.resolve({\n    \"type\": \"order_created\",\n    \"order_id\": \"12345\",\n    \"user_id\": \"67890\"\n}) == [\"Order created: 12345\"]\n# Note: `resolve` returns a list, because you can allow multiple routes for one event.\n\nassert app.resolve({\n    \"type\": \"order_delete\",\n    \"order_id\": \"12345\",\n    \"user_id\": \"67890\"\n})== [\"Order modification &lt;order_delete&gt;: 12345\"]\n</code></pre>"},{"location":"#complex-conditions","title":"Complex conditions","text":"<p>in depth field condition and condition combinations</p> <pre><code>from power_events import EventResolver\nfrom power_events.conditions import Value, Neg\n\napp = EventResolver()\n\n# Order created and digital purchase.\n@app.when(Value(\"type\").equals(\"order_created\") &amp; Value(\"cart.is_digital\").is_truthy())\ndef handle_digital_purchase(event: dict) -&gt; str:\n    return f\"The order created is a digital purchase: {event['order_id']}\"\n\n# Order created and physical.\n@app.when(Value(\"type\").equals(\"order_created\") &amp; Neg(Value(\"cart.is_digital\").is_truthy()))\ndef handle_physical_purchase(event: dict) -&gt; str:\n    return f\"The order created is a physical purchase: {event['order_id']}\"\n\n\nassert app.resolve({\n    \"type\": \"order_created\",\n    \"order_id\": \"12345\",\n    \"user_id\": \"67890\",\n    \"cart\": {\n        \"is_digital\": True,\n        \"items\": [\n            \"$10 voucher\"\n        ]\n    }\n}) == [\"The order created is a digital purchase: 12345\"]\nassert app.resolve({\n    \"type\": \"order_created\",\n    \"order_id\": \"12345\",\n    \"user_id\": \"67890\",\n    \"cart\": {\n        \"is_digital\": False,\n        \"items\": [\n            \"keyboard\"\n        ]\n    }\n}) == [\"The order created is a physical purchase: 12345\"]\n</code></pre> <p>It's possible to perform <code>OR</code>, <code>AND</code>, <code>NEG</code> operation over conditions.</p>"},{"location":"installation/","title":"Installation","text":"<p>Power-events has few dependencies:</p> <ul> <li>MayPy: Pythonic Java Optional</li> <li>typing-extensions: Backport of the standard library typing module.</li> </ul>"},{"location":"installation/#install-with-pip","title":"Install with pip","text":"pip install power-eventsinstalled! <p>Tip</p> <p>Don't forget to use a virtual environment when installing library, otherwise it will be installed on your global python environment.</p>"},{"location":"installation/#install-with-uv","title":"Install with UV","text":"<p>Information</p> <p>UV is a wonderful tools to manage your dependencies and packaging! I highly recommend to check it if you don't know Learn more </p> uv add power-eventsInstalling power-eventswriting lock file"},{"location":"installation/#install-with-poetry","title":"Install with poetry","text":"<p>Information</p> <p>Poetry is a great tools to manage your dependencies and packaging. I highly recommend to check it if you don't know Learn more </p> poetry add power-eventsInstalling power-eventswriting lock file"},{"location":"api/conditions/","title":"Base condition","text":""},{"location":"api/conditions/#conditions.condition.Condition","title":"Condition","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for a condition that can be checked against an event.</p>"},{"location":"api/conditions/#conditions.condition.Condition.check","title":"check  <code>abstractmethod</code>","text":"<pre><code>check(event: Event[V]) -&gt; bool\n</code></pre> <p>Check if the condition holds for the given event.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event[V]</code> <p>The event to check.</p> required"},{"location":"api/conditions/#conditions.condition.Condition.__or__","title":"__or__  <code>abstractmethod</code>","text":"<pre><code>__or__(other: Condition) -&gt; Condition\n</code></pre> <p>Combine this condition with another condition using OR logic.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Condition</code> <p>The other condition.</p> required"},{"location":"api/conditions/#conditions.condition.Condition.__and__","title":"__and__  <code>abstractmethod</code>","text":"<pre><code>__and__(other: Condition) -&gt; Condition\n</code></pre> <p>Combine this condition with another condition using AND logic.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Condition</code> <p>The other condition.</p> required"},{"location":"api/conditions/#conditions.condition.Condition.__invert__","title":"__invert__  <code>abstractmethod</code>","text":"<pre><code>__invert__() -&gt; Condition\n</code></pre> <p>Invert this condition (logical NOT).</p>"},{"location":"api/conditions/#conditions.condition.ConditionOperator","title":"ConditionOperator","text":"<p>               Bases: <code>Enum</code></p> <p>Enum representing logical operators for condition combination.</p>"},{"location":"api/conditions/#conditions.condition.ConditionOperator.__call__","title":"__call__","text":"<pre><code>__call__(*condition: Iterable[Any]) -&gt; bool\n</code></pre> <p>Apply the logical operator to the given conditions.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>Iterable[Any]</code> <p>The conditions to combine.</p> <code>()</code>"},{"location":"api/conditions/#conditions.condition.ConditionExpression","title":"ConditionExpression","text":"<pre><code>ConditionExpression(*conditions: Condition)\n</code></pre> <p>               Bases: <code>Condition</code>, <code>ABC</code></p> <p>Abstract base class for a composite condition expression.</p> <p>Parameters:</p> Name Type Description Default <code>conditions</code> <code>Condition</code> <p>The conditions that make up the expression.</p> <code>()</code>"},{"location":"api/conditions/#conditions.condition.ConditionExpression.__invert__","title":"__invert__  <code>abstractmethod</code>","text":"<pre><code>__invert__() -&gt; Condition\n</code></pre> <p>Invert this condition (logical NOT).</p>"},{"location":"api/conditions/#conditions.condition.Or","title":"Or","text":"<pre><code>Or(*conditions: Condition)\n</code></pre> <p>               Bases: <code>ConditionExpression</code></p> <p>Composite condition representing the logical OR of its conditions.</p> <p>Parameters:</p> Name Type Description Default <code>conditions</code> <code>Condition</code> <p>The conditions that make up the expression.</p> <code>()</code>"},{"location":"api/conditions/#conditions.condition.And","title":"And","text":"<pre><code>And(*conditions: Condition)\n</code></pre> <p>               Bases: <code>ConditionExpression</code></p> <p>Composite condition representing the logical AND of its conditions.</p> <p>Parameters:</p> Name Type Description Default <code>conditions</code> <code>Condition</code> <p>The conditions that make up the expression.</p> <code>()</code>"},{"location":"api/conditions/#conditions.condition.Neg","title":"Neg","text":"<pre><code>Neg(condition: Condition) -&gt; Condition\n</code></pre> <p>Create a new condition representing the logical NOT of the given condition.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>Condition</code> <p>The condition to invert.</p> required"},{"location":"api/exception/","title":"Exceptions","text":""},{"location":"api/exception/#exceptions.PowerEventsError","title":"PowerEventsError","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for exceptions of power_events.</p>"},{"location":"api/exception/#exceptions.ValueAbsentError","title":"ValueAbsentError","text":"<pre><code>ValueAbsentError(path: str, missing_key: str, event: Mapping[Any, Any])\n</code></pre> <p>               Bases: <code>PowerEventsError</code></p> <p>Exception raised when the value to check is not present inside the event.</p>"},{"location":"api/exception/#exceptions.NoPredicateError","title":"NoPredicateError","text":"<pre><code>NoPredicateError(path: str)\n</code></pre> <p>               Bases: <code>PowerEventsError</code></p> <p>Exception raised when no predicate has been set for a value condition.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path of the value condition.</p> required"},{"location":"api/exception/#exceptions.RouteError","title":"RouteError","text":"<p>               Bases: <code>PowerEventsError</code></p> <p>Base class for exceptions related to routing errors.</p>"},{"location":"api/exception/#exceptions.NoRouteFoundError","title":"NoRouteFoundError","text":"<pre><code>NoRouteFoundError(event: Mapping[Any, Any], routes: List[str])\n</code></pre> <p>               Bases: <code>RouteError</code></p> <p>Exception raised when no route is found for an event.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Mapping[Any, Any]</code> <p>The event that caused the error.</p> required <code>routes</code> <code>List[str]</code> <p>The list of registered route functions.</p> required"},{"location":"api/exception/#exceptions.MultipleRoutesError","title":"MultipleRoutesError","text":"<pre><code>MultipleRoutesError(event: Mapping[Any, Any], routes: List[str])\n</code></pre> <p>               Bases: <code>RouteError</code></p> <p>Exception raised when multiple routes are found for an event.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Mapping[Any, Any]</code> <p>The event that caused the error.</p> required <code>routes</code> <code>List[str]</code> <p>The list of available route functions.</p> required"},{"location":"api/resolver/","title":"Resolver","text":""},{"location":"api/resolver/#resolver.Func","title":"Func  <code>module-attribute</code>","text":"<pre><code>Func = Callable[Concatenate[Dict[Any, Any], P], Any]\n</code></pre>"},{"location":"api/resolver/#resolver.EventResolver","title":"EventResolver","text":"<pre><code>EventResolver(allow_multiple_routes: bool = False, allow_no_route: bool = True)\n</code></pre> <p>Class responsible for resolving events against registered routes.</p> <p>Parameters:</p> Name Type Description Default <code>allow_multiple_routes</code> <code>bool</code> <p>option to allow multiples routes on same event, otherwise raise <code>MultipleRoutesError</code>.</p> <code>False</code> <code>allow_no_route</code> <code>bool</code> <p>option to allow no routes on event, otherwise raise <code>NoRouteFoundError</code>.</p> <code>True</code>"},{"location":"api/resolver/#resolver.EventResolver.equal","title":"equal","text":"<pre><code>equal(value_path: str, expected: Any) -&gt; Callable[[Func[P]], Func[P]]\n</code></pre> <p>Register a route with an equality condition.</p> <p>Parameters:</p> Name Type Description Default <code>value_path</code> <code>str</code> <p>The path to the value in the event.</p> required <code>expected</code> <code>Any</code> <p>The expected value.</p> required"},{"location":"api/resolver/#resolver.EventResolver.one_of","title":"one_of","text":"<pre><code>one_of(value_path: str, options: Container[V]) -&gt; Callable[[Func[P]], Func[P]]\n</code></pre> <p>Register a route with a one-of condition.</p> <p>Parameters:</p> Name Type Description Default <code>value_path</code> <code>str</code> <p>The path to the value in the event.</p> required <code>options</code> <code>Container[V]</code> <p>The container of expected values.</p> required"},{"location":"api/resolver/#resolver.EventResolver.contain","title":"contain","text":"<pre><code>contain(value_path: str, *items: V) -&gt; Callable[[Func[P]], Func[P]]\n</code></pre> <p>Register a route where value should contain items.</p> <p>Parameters:</p> Name Type Description Default <code>value_path</code> <code>str</code> <p>The path to the value in the event.</p> required <code>items</code> <code>V</code> <p>Items to in the event.</p> <code>()</code>"},{"location":"api/resolver/#resolver.EventResolver.when","title":"when","text":"<pre><code>when(condition: Condition) -&gt; Callable[[Func[P]], Func[P]]\n</code></pre> <p>Register a route with a custom condition.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>Condition</code> <p>The condition to trigger this route.</p> required"},{"location":"api/resolver/#resolver.EventResolver.resolve","title":"resolve","text":"<pre><code>resolve(event: Mapping[Any, V]) -&gt; Sequence[Any]\n</code></pre> <p>Resolve the event to the matching routes and execute their functions.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Mapping[Any, V]</code> <p>The event to resolve.</p> required"},{"location":"api/value/","title":"Value","text":""},{"location":"api/value/#conditions.value.Absent","title":"Absent","text":"<p>Sentinel class to represent value absence.</p>"},{"location":"api/value/#conditions.value.ValuePath","title":"ValuePath","text":"<p>               Bases: <code>str</code></p> <p>A path-like string for accessing nested mappings value.</p>"},{"location":"api/value/#conditions.value.ValuePath.__new__","title":"__new__","text":"<pre><code>__new__(path: str, *, separator: Optional[str] = None) -&gt; Self\n</code></pre> <p>Create a new ValuePath object from a path string.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>path string of a value inside a mapping object.</p> required <code>separator</code> <code>Optional[str]</code> <p>custom separator to use instead of the default.</p> <code>None</code>"},{"location":"api/value/#conditions.value.ValuePath.get","title":"get","text":"<pre><code>get(mapping: Mapping[Any, V], default: Union[V, None, Absent] = ABSENT, *, raise_if_absent: bool = False) -&gt; Union[Any, None, Absent]\n</code></pre> <p>Get the value describe by the path inside mapping object.</p> <p>The value returns can be the sentinel <code>ABSENT</code> to differentiate real <code>None</code> value of default.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping[Any, V]</code> <p>Dictionary or mapping object to lookup.</p> required <code>default</code> <code>Union[V, None, Absent]</code> <p>Default value if key not found. By default return the sentinel value <code>ABSENT</code>.</p> <code>ABSENT</code> <code>raise_if_absent</code> <code>bool</code> <p>Flag to raise <code>ValueAbsentError</code> if missing key. Default <code>False</code></p> <code>False</code> Note <p>Support both string and integer keys.</p> <p>Raises:</p> Type Description <code>ValueAbsentError</code> <p>if parameter <code>raise_if_absent</code> set, and key is missing.</p>"},{"location":"api/value/#conditions.value.Value","title":"Value","text":"<pre><code>Value(value_path: str, mapper: Optional[Mapper[Any, Any]] = None)\n</code></pre> <p>               Bases: <code>Condition</code></p> <p>Condition based on a value at a certain path in an event.</p> <p>Parameters:</p> Name Type Description Default <code>value_path</code> <code>str</code> <p>The path to the value in the event.</p> required <code>mapper</code> <code>Optional[Mapper[Any, Any]]</code> <p>mapper to transform value before checking predicates on it.</p> <code>None</code>"},{"location":"api/value/#conditions.value.Value.root","title":"root  <code>classmethod</code>","text":"<pre><code>root() -&gt; Self\n</code></pre> <p>Initialize value targeting condition over the event itself.</p> <p>Examples:</p> <pre><code>Value.root().contains(\"a\").check(my_dict)\n#  is equivalent to.\n\"a\" in my_dict\n</code></pre>"},{"location":"api/value/#conditions.value.Value.check","title":"check","text":"<pre><code>check(event: Event[V], *, raise_if_absent: bool = False) -&gt; bool\n</code></pre> <p>Check the given event respect the value condition.</p> <p>By default, the event fails the check if the value is absent, an error can be raised, by setting the flag <code>raise_if_absent</code>.</p> <p>Raises:</p> Type Description <code>NoPredicateError</code> <p>when no predicate has been set.</p> <code>ValueAbsentError</code> <p>if a key define by the path is missing in event.</p>"},{"location":"api/value/#conditions.value.Value.is_truthy","title":"is_truthy","text":"<pre><code>is_truthy() -&gt; Self\n</code></pre> <p>Add value is truthy check to the condition.</p>"},{"location":"api/value/#conditions.value.Value.equals","title":"equals","text":"<pre><code>equals(expected: Any) -&gt; Self\n</code></pre> <p>Add value equals the expected value check to the condition.</p> <p>Parameters:</p> Name Type Description Default <code>expected</code> <code>Any</code> <p>The expected value.</p> required"},{"location":"api/value/#conditions.value.Value.match_regex","title":"match_regex","text":"<pre><code>match_regex(regex: Pattern[str]) -&gt; Self\n</code></pre><pre><code>match_regex(regex: str, flags: Union[RegexFlag, int] = 0) -&gt; Self\n</code></pre> <pre><code>match_regex(regex: Union[Pattern[str], str], flags: Union[RegexFlag, int] = 0) -&gt; Self\n</code></pre> <p>Add value matches the given regex pattern check to the condition.</p> <p>Parameters:</p> Name Type Description Default <code>regex</code> <code>Union[Pattern[str], str]</code> <p>regex to match (either a string or a Pattern)</p> required <code>flags</code> <code>Union[RegexFlag, int]</code> <p>regex flags; should bot be passed with a pattern.</p> <code>0</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>when passing flags whereas a <code>Pattern</code> have been passed</p>"},{"location":"api/value/#conditions.value.Value.one_of","title":"one_of","text":"<pre><code>one_of(options: Container[Any]) -&gt; Self\n</code></pre> <p>Add value is one of the given options check to the condition.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>Container[Any]</code> <p>The container of options.</p> required"},{"location":"api/value/#conditions.value.Value.contains","title":"contains","text":"<pre><code>contains(*items: Any) -&gt; Self\n</code></pre> <p>Add value contains all the given items to the condition.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>Any</code> <p>The items to check for.</p> <code>()</code>"},{"location":"api/value/#conditions.value.Value.is_not_empty","title":"is_not_empty","text":"<pre><code>is_not_empty() -&gt; Self\n</code></pre> <p>Add value is not empty to the condition.</p>"},{"location":"api/value/#conditions.value.Value.is_length","title":"is_length","text":"<pre><code>is_length(length: int) -&gt; Self\n</code></pre> <p>Add value has the specified size to the condition.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>The length expected.</p> required"},{"location":"api/value/#conditions.value.Value.match","title":"match","text":"<pre><code>match(predicate: Predicate[Any]) -&gt; Self\n</code></pre> <p>Add value matches the given predicate to the condition.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Predicate[Any]</code> <p>The predicate to apply.</p> required"},{"location":"api/value/#conditions.value.combine","title":"combine","text":"<pre><code>combine(*predicates: Predicate[Any]) -&gt; Predicate[Any]\n</code></pre> <p>Combine all provided predicates into a single predicate.</p> <p>Parameters:</p> Name Type Description Default <code>predicates</code> <code>Predicate[Any]</code> <p>Predicates to combine.</p> <code>()</code>"},{"location":"usage/","title":"Analogy","text":"<p>Like in FastAPI you can define route depends on request path and HTTP verb.</p> <p>With Power-Event, You can define route depends on business rule upon your event.</p> <p>This toturial will show you how to use Power-events through examples, step by step.</p> <p>All the code presented can be copied and used directly (of course you need to have power-events installed )</p>"},{"location":"usage/conditions/","title":"Conditions","text":"<p>The true power of Power-event lays on its condition system. It can combine multiple conditions the same way it's possible in Boolean Algebra.</p> <p>This way, you can use these operators:</p> ANDORNOT <pre><code>from power_events.conditions import And\n\ncondition1 &amp; condition2\n# Or this way\nAnd(condition1, condition2, ...)\n</code></pre> <pre><code>from power_events.conditions import Or\n\ncondition1 | condition2\n# Or this way\nOr(condition1, condition2, ...)\n</code></pre> <pre><code>from power_events.conditions import Neg\n\n~condition1\n# Or this way\nNeg(condition1)\n</code></pre>"},{"location":"usage/conditions/#whats-a-condition","title":"What's a condition ?","text":"<p>A condition is defining by two things:</p> <ul> <li> <p>A set of predicates to a certain value (precisely a path to value in the event), in order to verify if the event matches it.</p> </li> <li> <p>And as said previously, the ability to be compatible with Boolean Algebra.</p> </li> </ul>"},{"location":"usage/conditions/#lets-create-some","title":"Let's create some","text":"<p>The entrypoint to create a condition is <code>Value</code>. With which, we define the value path in the event to check under the predicate given.</p>"},{"location":"usage/conditions/#path","title":"Path","text":"<p>The path to a value is a string containing all the keys to reach it inside an event. It allows get a value at any depth level.</p> <p>Each key should be separated by a <code>.</code>, otherwise it may:</p> <ul> <li>Either raise a validation error.<ul> <li>By beginning by separator. <code>.menu</code> </li> <li>By ending by separator. <code>menu.</code> </li> <li>Use consecutive separators. <code>menu..dessert</code> </li> </ul> </li> <li>Or worst, not work as expected!</li> </ul> <pre><code># this path\npath = \"menu.desserts.parfait\"\n# is equivalent to this with the event\nevent[\"menu\"][\"desserts\"][\"parfait\"]\n</code></pre>"},{"location":"usage/conditions/#predicate","title":"Predicate","text":"<p>To add predicate at the value check, you can either use built-in method (like <code>equals</code>, <code>one_of</code>, etc.), or using yours, passing it to the method <code>match</code>.</p> <p>Each time you add a predicate, it's combined with the current.</p> <pre><code>from power_events.conditions import Value\n\ndesserts_minimum_selection = Value(\"menu.dessert\").contains(\"parfait\", \"crepes\", \"cookie\")\nparfait_price_cond = Value(\"menu.desserts.parfait.price\").match(lambda price: 0 &lt; price &lt; 10)\n\nevent = {\n    \"restaurant\": \"La maison\",\n    \"menu\": {\n        \"entrees\": {},\n        \"dishes\": {},\n        \"desserts\": {\n            \"flan\": {},\n            \"crepes\": {},\n            \"parfait\": {\n                \"price\": 6.5\n            },\n            \"cookie\": {}\n        }\n    }\n}\n\"\"\" Here we check that the menu as minimum cookie, crepes and parfait as dessert,\n*and* parfait price is between $0 and $10.\n\"\"\"\nassert (desserts_minimum_selection &amp; parfait_price_cond).check(event)\n</code></pre> <p>Things to know</p> <ul> <li>String and integer keys are supported.</li> <li>If the value is absent:<ul> <li>By default, the event fails the condition.</li> <li>You can raise an error using the option <code>raise_if_absent</code>, and a <code>ValueAbsentError</code> exception will be raised.</li> </ul> </li> </ul>"},{"location":"usage/conditions/#mapping","title":"Mapping","text":"<p>Sometimes, the value in event has been serialized to simplify the format, like date passed as timestamp or iso format. You can provide a mapper, to choose how the value will be check.</p> <p>An example with date, the menu carte should be the menu of the week. But, the date is represented as a string.</p> <pre><code>from datetime import datetime, timedelta\n\nfrom power_events.conditions import Value\n\nDATE_FORMAT = \"%Y-%m-%d\"\n\n\ndef to_datetime(value: str) -&gt; datetime:\n    return datetime.strptime(value, DATE_FORMAT)\n\n\ndate_cond = Value(\"effective-date\", to_datetime).match(lambda val: val &gt;= (datetime.now() - timedelta(weeks=1)))\n\nevent = {\n    \"restaurant\": \"La maison\",\n    \"effective-date\": (datetime.now() - timedelta(days=2)).strftime(DATE_FORMAT),\n    \"menu\": {\n        \"entrees\": {},\n        \"dishes\": {},\n        \"desserts\": {}\n    }\n}\n\nassert date_cond.check(event)\n</code></pre>"},{"location":"usage/conditions/#combination","title":"Combination","text":"<p>As show before, it's possible to combine <code>Value</code> (using And or Or logic). But it's also possible de combine the resulting condition, and so on, to have a tree of conditions.</p> <p>To have something like this:</p> CodeGraph <pre><code>from typing import Union\n\nfrom power_events.conditions import Value\n\ndesserts_minimum_selection = Value(\"menu.dessert\").contains(\"parfait\", \"crepes\", \"cookie\")\n\ndef valid_range_price(price: Union[float, int]) -&gt; bool:\n    return 0 &lt; price &lt; 10\n\nparfait_price_cond = Value(\"menu.desserts.parfait.price\").match(valid_range_price)\ncrepes_price_cond = Value(\"menu.desserts.crepes.price\").match(valid_range_price)\n\nrestaurant_name_cond = Value(\"restaurant\").is_not_empty()\n\ncondition = restaurant_name_cond &amp; (\n    desserts_minimum_selection &amp; (parfait_price_cond | crepes_price_cond)\n    )\n</code></pre> <pre><code>graph TD\n    A[AND] --&gt; B[restaurant_name_cond]\n    A --&gt; C[AND]\n    C --&gt; D[desserts_minimum_selection]\n    C --&gt; E[OR]\n    E --&gt; F[parfait_price_cond]\n    E --&gt; H[crepes_price_cond]</code></pre>"},{"location":"usage/first_steps/","title":"First steps","text":"<p>The simplest example could look like this:</p> <pre><code>from power_events import EventResolver\n\napp = EventResolver()\n\n@app.equal(\"type\", \"power-event\")\ndef handle_example(event):\n    return \"Hello from power-event type event\"\n\n\nprint(app.resolve({\"type\": \"power-event\"}))\n# [\"Hello from power-event type event\"]\n</code></pre>"},{"location":"usage/first_steps/#recap-step-by-step","title":"Recap, step by step","text":""},{"location":"usage/first_steps/#step-1-create-an-eventresolver","title":"Step 1: create an <code>EventResolver</code>","text":"<pre><code>from power_events import EventResolver\n\napp = EventResolver()\n\n@app.equal(\"type\", \"power-event\")\ndef handle_example(event):\n    return \"Hello from power-event type event\"\n\n\nprint(app.resolve({\"type\": \"power-event\"}))\n# [\"Hello from power-event type event\"]\n</code></pre> <p>Here <code>app</code> will be an instance of <code>EventResolver</code>, it's the main entrypoint to define our event routes.</p>"},{"location":"usage/first_steps/#step-2-create-a-event-route-operation","title":"Step 2: create a event route operation","text":""},{"location":"usage/first_steps/#path","title":"Path","text":"<p>\"Path\" here refers to our condition path, it's the path of our value inside the event.</p>"},{"location":"usage/first_steps/#condition-operation","title":"Condition operation","text":"<p>\"Operation\" can be either built-in operation like one of:</p> <ul> <li><code>equal</code></li> <li><code>one_of</code></li> <li><code>contain</code></li> </ul> <p>Or custom passing ours with <code>when</code>.</p>"},{"location":"usage/first_steps/#define-our-route","title":"Define our route","text":"<pre><code>from power_events import EventResolver\n\napp = EventResolver()\n\n@app.equal(\"type\", \"power-event\")\ndef handle_example(event):\n    return \"Hello from power-event type event\"\n\n\nprint(app.resolve({\"type\": \"power-event\"}))\n# [\"Hello from power-event type event\"]\n</code></pre> <p><code>@app.equal(\"type\", \"power-event\")</code> tells at Power-Events that the function define below to be triggered if an event with the value at path <code>type</code> is equals at <code>power-event</code>.</p> <p>About <code>@decorator</code></p> <p>the <code>@</code> syntax in Python is called a \"decorator\".</p> <p>It's a shorthand to <code>decorator(function)</code>.</p> <p>A decorator is a function that takes a function to do something with it.</p> <p>In our case, it registers the function in our Resolver, that way it will be called corresponding to the condition given. Here when 'type' is equal to 'power-event'.</p>"},{"location":"usage/first_steps/#function-constraint","title":"Function constraint","text":"<pre><code>from power_events import EventResolver\n\napp = EventResolver()\n\n@app.equal(\"type\", \"power-event\")\ndef handle_example(event):\n    return \"Hello from power-event type event\"\n\n\nprint(app.resolve({\"type\": \"power-event\"}))\n# [\"Hello from power-event type event\"]\n</code></pre> <p>Currently, there is a one constraint on the function handler signature, it should have as first argument the event.</p> <p>Otherwise, a TypeError will occur saying an argument was passed.</p>"},{"location":"usage/routing/","title":"Event handling","text":"<p>Now we have the basis, let's deep dive a bit further to have a global view of the features.</p>"},{"location":"usage/routing/#options","title":"Options","text":"<p>When declaring a event resolver, some options can be passed depending on you needs.</p> <p>Tip</p> <p>If you feel like some options or functionalities are missing, feel free to open an issue !</p> <p>More could arrive this way.</p>"},{"location":"usage/routing/#multiple-routes","title":"Multiple routes","text":"<p>To prevent unexpected behaviour, by default an event meeting conditions of different routes, will raise <code>MultipleRouteError</code>. However, in case of intended multiple routes conditions matching an event. The option <code>allow_multiple_route</code> at resolver definition can be passed, this way, all routes passing will be called.</p> DefaultWith <code>allow_multiple_route</code> option <pre><code>from power_events import EventResolver\n\napp = EventResolver()\n\n@app.one_of(\"type\", [\"create\", \"delete\"])\ndef handle_operation(event: dict) -&gt; None:\n    \"\"\"Some logic.\"\"\"\n\n@app.equal(\"type\", \"delete\")\ndef handle_deletion(event: dict) -&gt; None:\n    \"\"\"Deletion logic\"\"\"\n\nevent = {\n    \"type\": \"delete\"\n    # Other fields\n}\n\napp.resolve(event)\nE   power_events.exceptions.MultipleRoutesError: Multiples routes found for the current event: {'type': 'delete'}.\nE   Available route functions are handle_operation, handle_deletion.\nE   If it's normal pass the option 'allow_multiple_routes' in the resolver definition.\n</code></pre> <pre><code>from power_events import EventResolver\n\napp = EventResolver(allow_multiple_routes=True)\n\n@app.one_of(\"type\", [\"create\", \"delete\"])\ndef handle_operation(event: dict) -&gt; None:\n    \"\"\"Some logic.\"\"\"\n\n@app.equal(\"type\", \"delete\")\ndef handle_deletion(event: dict) -&gt; None:\n    \"\"\"Deletion logic\"\"\"\n\nevent = {\n    \"type\": \"delete\"\n    # Other fields\n}\n\napp.resolve(event) # no error\n# handle_operation and handle_deletion call\n</code></pre>"},{"location":"usage/routing/#no-route","title":"No route","text":"<p>Because all events may not have to be processed by your application, by default power-events allow it.</p> <p>Of course, you can raise an error otherwise when an event doesn't meet any route. same as before, just an option. Pass <code>allow_no_route</code>to <code>False</code>, and it's done!</p> DefaultWithout <code>allow_no_route</code> option <pre><code>from power_events import EventResolver\n\napp = EventResolver()\n\n@app.one_of(\"type\", [\"create\", \"delete\"])\ndef handle_operation(event: dict) -&gt; None:\n    \"\"\"Some logic.\"\"\"\n\n@app.equal(\"type\", \"delete\")\ndef handle_deletion(event: dict) -&gt; None:\n    \"\"\"Deletion logic\"\"\"\n\nevent = {\n    \"type\": \"update\"\n    # Other fields\n}\n\napp.resolve(event) # no route has been called.\n</code></pre> <pre><code>from power_events import EventResolver\n\napp = EventResolver(allow_no_route=False)\n\n@app.one_of(\"type\", [\"create\", \"delete\"])\ndef handle_operation(event: dict) -&gt; None:\n    \"\"\"Some logic.\"\"\"\n\n@app.equal(\"type\", \"delete\")\ndef handle_deletion(event: dict) -&gt; None:\n    \"\"\"Deletion logic\"\"\"\n\nevent = {\n    \"type\": \"delete\"\n    # Other fields\n}\n\napp.resolve(event)\n&gt;&gt;&gt; power_events.exceptions.NoRouteFoundError: No route found for the current event: {'a': 1}.\n&gt;&gt;&gt; Registered route functions are .\n&gt;&gt;&gt; If it's normal pass the option 'allow_no_route' at `False` in the resolver definition.\n</code></pre>"},{"location":"usage/routing/#route","title":"Route","text":"<p>As saw before, it is possible to register a route using built-in condition preset.</p> <ul> <li>equal: when one field should be equal.</li> <li>one_of: when one field should be one of the options.</li> <li>contain: when one field should contain item(s).</li> </ul> Example<pre><code>from typing import Any\n\nfrom power_events import EventResolver\n\napp = EventResolver()\n\n@app.equal(\"my-field1\", 1)\ndef handle_route_1(event: dict) -&gt; Any:\n    \"\"\"route logic.\"\"\"\n</code></pre> <p>But often, business logic is not that simple. It needs to rely on more that one field, and much, much, much more complex and subtil condition.</p> <p>No Problem!</p> <p>The core has been design to meet any condition without concession.</p> <p>Info</p> <p>For that, if you haven't check the section about condition, check it out before continuing .</p> <p>We can use custom conditions,  using either built-in predicate function or your own,  and combine it with on different event fields. As another possibility, you can also perform a condition over the whole event itself by the <code>Value.root</code>.</p> <p><code>when</code> is here to respond to any use case above. All condition concepts are usable!</p> <pre><code>from datetime import datetime, date\nfrom power_events.conditions import Value\nfrom power_events import EventResolver\n\napp = EventResolver()\n\n\ndef my_predicate(value: str) -&gt; bool:\n    \"\"\"condition logic.\"\"\"\n\n\ndef to_date(value: str) -&gt; date:\n    return datetime.strptime(value, \"%Y-%m-%d\").date()\n\n\n@app.when(Value(\"body\").match(my_predicate))\ndef handle_field(event: dict) -&gt; None:\n    \"\"\"Route on 'body' value\"\"\"\n\n\n@app.when(Value.root().contains(\"error\"))\ndef handle_field(event: dict) -&gt; None:\n    \"\"\"Route if event contains 'error'\"\"\"\n\n\n@app.when(Value(\"body.date\", to_date).equals(lambda val: val == date.today()) \n          &amp; Value(\"body.name\").equals(\"creation\"))\ndef handle_today_creation(event: dict) -&gt; None:\n    \"\"\"Route if event body date is today and it's a creation\"\"\"\n</code></pre>"}]}